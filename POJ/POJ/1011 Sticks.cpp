/*

解题思路：
思想很简单，一个接一个的把木棍拼起来，最后把木棍用光。
关键的地方是几个剪枝技巧：
设所有木棍的总长度为 Sum, 最终的答案（长度）是 L。
1. 首先要明白， Sum一定要能被 L 整除。
2. L 一定 大于等于 题目给出的最长的木棍的长度 Max。
由上述两点，我们想到，可以从 Max 开始递增地枚举 L,
直到成功地拼出 Sum/L 支长度为 L 的木棍。
搜索中的剪枝技巧：
3. 将输入的输入从大到小排序，这么做是因为一支长度为 K
的完整木棍，总比几支短的小木棍拼成的要好。
形象一些：
如果我要拼 2 支长为8的木棍，第一支木棍我拼成
5 + 3
然后拼第二支木棍但是失败了，而我手中还有长为 2 和 1
的木棍，我可以用 5 + 2 + 1 拼好第一支，再尝试拼第二
支，仔细想一想，就会发现这样做没意义，注定要失败的。
我们应该留下 2+1 因为 2+1 比 3 更灵活。
4. 相同长度的木棍不要搜索多次， 比如：
我手中有一些木棍, 其中有 2 根长为 4 的木棍， 当前搜索
状态是 5+4+.... (即表示长度为 5,4,2 的三支拼在一起,
...表示深层的即将搜索的部分), 进行深搜后不成功，故我
没必要用另一个 4 在进行 5+4+...
5. 将开始搜索一支长为 L 的木棍时，我们总是以当前最长的未
被使用的 木棍开始，如果搜索不成功，那么以比它短的开始
那么也一定不能取得全局的成功。因为每一支题目给出的木棍
都要被用到。
如果，有
4
5 4 4 3 2
想拼成长为 6 的木棍，那么从 5 开始， 但是显然没有能与 5
一起拼成 6 的，那么我就没必要去尝试从 4 开始的，因为
最终 5 一定会被遗弃。在拼第 2 3 ... 支木棍时，一样。
*/

#include<cstdio>
#include<cstdlib>
#include<cstring>

int len[65];
bool used[65];
int sum, L, n;

int cmp(const void *a, const void *b)
{
	return *(int *)b - *(int *)a;
}

bool DFS(int m, int left)    //m为剩余的未用的木棒数，left为当前正在拼接的木棒和假定的木棒长度L比还缺少的长度
{
	if (m == 0 && left == 0)
		return true;
	if (left == 0)     //一根刚刚拼完开始拼新的一根
		left = L;
	for (int i = 0; i<n; ++i)
	{
		if (!used[i] && len[i] <= left)
		{
			if (i>0)
			{
				if (!used[i - 1] && len[i] == len[i - 1])    //第一次剪枝：没有这一条减枝63ms
					continue;                        //如果当前的没用过的棒子不可用，那么和他长度相同的未使用的棒子也不可用，直接跳过
			}
			used[i] = true;
			if (DFS(m - 1, left - len[i]))
				return true;

			used[i] = false;//说明不能用i作为第一条，那么要拆以前的木棒，i还可能用在以前的木棒中，所以回溯
			if (len[i] == left || left == L)  //重要剪枝---很重要否则会超时
				return false;          //将开始搜索一支长为 L 的木棍时，我们总是以当前最长的未
			                             //被使用的 木棍开始，如果搜索不成功，那么以比它短的开始
		}                                   //也一定不能取得全局的成功。因为每一支题目给出的木棍都要被用到。
	}                                       //这里用时16Ms，去掉len[i]==left这个条件(不太懂---网上说当前木棒是最后一根木棒  67行 放入这根木棍构成L 剩余的是无法构成L的倍数的)变成47Ms，而去掉left==L这个条件会超时
	return false;
}

int main()
{
	while (scanf("%d", &n), n)
	{
		sum = 0;
		for (int i = 0; i<n; ++i)
		{
			scanf("%d", &len[i]);
			sum += len[i];
		}
		qsort(len, n, sizeof(int), cmp);       //从大到小排序
		for (L = len[0]; L <= sum / 2; ++L)          //若L>sum/2则只有一种可能就是所有木棒只能拼接成一根。
		{
			if (sum%L)
				continue;
			memset(used, false, sizeof(used));
			if (DFS(n, L))
			{
				printf("%d\n", L);
				break;
			}
		}
		if (L>sum / 2)
			printf("%d\n", sum);
	}
	return 0;
}